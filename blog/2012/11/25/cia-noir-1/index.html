<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Clojure实战(1)：使用Noir框架开发博客(上) | Ji ZHANG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。
Clojure已经有一些不错的教程，如Mark Volkmann的Clojure - Functional Programming for the JVM，Storm的主要贡献者徐明">
<meta property="og:type" content="article">
<meta property="og:title" content="Clojure实战(1)：使用Noir框架开发博客(上)">
<meta property="og:url" content="http://shzhangji.com/blog/2012/11/25/cia-noir-1/index.html">
<meta property="og:site_name" content="Ji ZHANG's Blog">
<meta property="og:description" content="前言为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。
Clojure已经有一些不错的教程，如Mark Volkmann的Clojure - Functional Programming for the JVM，Storm的主要贡献者徐明">
<meta property="og:updated_time" content="2016-08-08T14:57:42.571Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clojure实战(1)：使用Noir框架开发博客(上)">
<meta name="twitter:description" content="前言为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。
Clojure已经有一些不错的教程，如Mark Volkmann的Clojure - Functional Programming for the JVM，Storm的主要贡献者徐明">
<meta name="twitter:creator" content="@zjerryj">
<link rel="publisher" href="zhangji87@gmail.com">
  
    <link rel="alternate" href="/atom.xml" title="Ji ZHANG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-37223379-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ji ZHANG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">If I rest, I rust.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shzhangji.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cia-noir-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2012/11/25/cia-noir-1/" class="article-date">
  <time datetime="2012-11-25T16:58:00.000Z" itemprop="datePublished">2012-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tutorial/">Tutorial</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Clojure实战(1)：使用Noir框架开发博客(上)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。</p>
<p>Clojure已经有一些不错的教程，如<a href="http://java.ociweb.com/mark/" target="_blank" rel="external">Mark Volkmann</a>的<a href="http://java.ociweb.com/mark/clojure/article.html" target="_blank" rel="external">Clojure - Functional Programming for the JVM</a>，Storm的主要贡献者<a href="http://xumingming.sinaapp.com/" target="_blank" rel="external">徐明明</a>也对这个教程做了<a href="http://xumingming.sinaapp.com/302/clojure-functional-programming-for-the-jvm-clojure-tutorial/" target="_blank" rel="external">全文翻译</a>。还有一些不错的书籍，像<a href="http://oreilly.com/" target="_blank" rel="external">O’Reilly</a>的<a href="http://www.amazon.com/Clojure-Programming-Chas-Emerick/dp/1449394701" target="_blank" rel="external">Clojure Programming</a>，都值得一读。我是从Mark的教程开始学起的，对其中没有提到的部分则是参考了Clojure Programming这本书。Clojure的<a href="http://clojure.org/" target="_blank" rel="external">官方网站</a>上有详尽的<a href="http://clojure.github.com/clojure/" target="_blank" rel="external">API参考</a>，可以作为工具书查阅。</p>
<p>但是，上面提到的教程都是针对Clojure语言本身的，从 <em>Hello, world!</em> 开始，讲解Clojure的各种语法，关键字，结构等等。虽然Clojure的语法已经足够吸引你的眼球，在<a href="http://en.wikipedia.org/wiki/Read-eval-print_loop" target="_blank" rel="external">REPL</a>中敲击Clojure代码已经是一种莫大的乐趣了，但似乎还有些不够，我们想看到一个用Clojure编写的应用程序！</p>
<p>因为平时都是做Web开发，所以先从一个Web框架入手会是不错的选择，因此这份教程会从使用<a href="http://webnoir.org/" target="_blank" rel="external">Noir</a>框架搭建一个博客开始，带你领略Clojure的魅力。</p>
<a id="more"></a>
<h2 id="一句话概述Clojure"><a href="#一句话概述Clojure" class="headerlink" title="一句话概述Clojure"></a>一句话概述Clojure</h2><p><strong>Clojure是一种运行在JVM平台上的函数式编程语言。</strong></p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Jvm" target="_blank" rel="external">JVM平台</a>：历史悠久，应用广泛，成熟稳定。Clojure可以和Java程序交互，调用各种类库，与现有系统整合。</li>
<li><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">函数式编程</a>：<a href="http://en.wikipedia.org/wiki/LISP" target="_blank" rel="external">Lisp</a>的一种方言，表达力强，是解决高并发问题的利器。</li>
</ul>
<h2 id="安装Clojure"><a href="#安装Clojure" class="headerlink" title="安装Clojure"></a>安装Clojure</h2><p>Clojure是以一个Jar包发行的，可以到<a href="http://clojure.org/getting_started" target="_blank" rel="external">官网下载</a>后使用<code>java -jar</code>命令运行。而在实际开发中，我们会选择使用<a href="https://github.com/technomancy/leiningen" target="_blank" rel="external">Leiningen</a>或<a href="http://maven.apache.org/" target="_blank" rel="external">Maven</a>来管理Clojure项目，本教程将以Leiningen（命令行是<code>lein</code>）作为项目管理工具进行讲解。</p>
<h3 id="安装Leiningen"><a href="#安装Leiningen" class="headerlink" title="安装Leiningen"></a>安装Leiningen</h3><p><code>lein</code>目前有1.x和2.x两个版本，后者还在alpha阶段。使用以下命令安装<code>lein</code> 1.x版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/bin <span class="comment"># 假设$HOME/bin目录在系统的$PATH中</span></div><div class="line">$ wget https://raw.github.com/technomancy/leiningen/stable/bin/lein</div><div class="line">$ chmod 755 lein</div><div class="line">$ lein self-install</div><div class="line">$ lein repl</div><div class="line">REPL started; server listening on localhost port 1096</div><div class="line">user=&gt;</div></pre></td></tr></table></figure>
<p>这样就已经安装好了<code>lein</code>和Clojure环境，并启动了一个REPL，可以直接运行Clojure代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user=&gt; (+ 1 2)</div><div class="line">3</div><div class="line">user=&gt;</div></pre></td></tr></table></figure>
<p>这里出现了Clojure的两个特点：圆括号和前缀表达式。Clojure的基本语法是<code>(fn1 arg1 (fn2 arg2 arg3))</code>。函数是Clojure中的“一等公民”，它即是可执行的代码，又是一种数据（类似闭包的概念）。以后我们会慢慢熟悉。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ lein new proj</div><div class="line">$ find proj</div><div class="line">proj</div><div class="line">proj/project.clj</div><div class="line">proj/src/proj/core.clj</div><div class="line">$ cat proj/project.clj</div><div class="line">(defproject proj <span class="string">"1.0.0-SNAPSHOT"</span></div><div class="line">  :description <span class="string">"FIXME: write description"</span></div><div class="line">  :dependencies [[org.clojure/clojure <span class="string">"1.3.0"</span>]])</div></pre></td></tr></table></figure>
<p><code>lein new</code>命令用来创建一个Clojure项目骨架，最重要的文件是<code>project.clj</code>，它声明了项目的基本属性以及依赖包。</p>
<p><code>lein plugin</code>命令可以用来管理lein的插件，我们可以通过安装lein-noir插件来生成基于Noir的项目骨架：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ lein plugin install lein-noir 1.2.1</div><div class="line">$ lein noir new blog</div><div class="line">$ find blog</div><div class="line">blog</div><div class="line">blog/project.clj</div><div class="line">blog/resources/public/css/reset.css</div><div class="line">blog/resources/public/img</div><div class="line">blog/resources/public/js</div><div class="line">blog/src/blog/models</div><div class="line">blog/src/blog/server.clj</div><div class="line">blog/src/blog/views/common.clj</div><div class="line">blog/src/blog/views/welcome.clj</div></pre></td></tr></table></figure>
<p>我们可以直接运行这个项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ lein run</div><div class="line">Starting server...</div><div class="line">2012-11-29 22:34:39.174:INFO::jetty-6.1.25</div><div class="line">2012-11-29 22:34:39.237:INFO::Started SocketConnector@0.0.0.0:8080</div></pre></td></tr></table></figure>
<p>浏览<a href="http://localhost:8080，就能看到项目的页面了。" target="_blank" rel="external">http://localhost:8080，就能看到项目的页面了。</a></p>
<h2 id="Noir项目的基本结构"><a href="#Noir项目的基本结构" class="headerlink" title="Noir项目的基本结构"></a>Noir项目的基本结构</h2><h3 id="项目基本信息：project-clj"><a href="#项目基本信息：project-clj" class="headerlink" title="项目基本信息：project.clj"></a>项目基本信息：project.clj</h3><p>Clojure文件都是以<code>.clj</code>为扩展名的。项目根目录下的project.clj文件包含了一些基本信息，我们逐一分析：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defproject</span> blog <span class="string">"0.1.0-SNAPSHOT"</span></div><div class="line">            <span class="symbol">:description</span> <span class="string">"FIXME: write this!"</span></div><div class="line">            <span class="symbol">:dependencies</span> [[org.clojure/clojure <span class="string">"1.3.0"</span>]</div><div class="line">                           [noir <span class="string">"1.2.1"</span>]]</div><div class="line">            <span class="symbol">:main</span> blog.server)</div></pre></td></tr></table></figure>
<p><a href="http://clojuredocs.org/leiningen/leiningen.core/defproject" target="_blank" rel="external">defproject</a>是Leiningen定义的一个<a href="http://clojure.org/macros" target="_blank" rel="external">宏</a>，用来描述项目的基本信息。宏在Clojure中是一个很重要的语言特性，简单地说，开发者可以用宏创造出新的语法。</p>
<p>:description、:main等是一种直接量(literal)，我们称之为关键字(keyword)，通常以<code>:</code>开头，主要用来作为哈希表(map)中的键名，这里则用来表示项目的某种信息，从名称上应该很好理解。</p>
<p><code>[1 [&quot;b&quot;, false]]</code>中的<code>[...]</code>表示一个向量(vector)，它的元素可以是任意类型，元素之间以空格或逗号分隔。这行代码也展示了Clojure中其他几种直接量：数值型、字符串、布尔型。</p>
<p>依赖项的描述也很直观，<code>[groupId/artifactId &quot;version&quot;]</code>。Clojure使用了和Maven相似的包命名方式，当groupId和artifactId相同时，可以进行简写，如<code>[noir &quot;1.2.1&quot;]</code>等价于<code>[noir/noir &quot;1.2.1&quot;]</code>，这也是Clojure鼓励的做法。对依赖项进行修改后，可以运行<code>lein deps</code>命令进行安装。lein会先从<a href="https://clojars.org" target="_blank" rel="external">Clojars</a>上查找和下载，不存在时再到<a href="http://search.maven.org/" target="_blank" rel="external">Maven中央仓库</a>中搜索。</p>
<p>最后，:main顾名思义指向的是程序入口，它配置的是一个命名空间，其中会包含一个<code>-main</code>方法（注意方法名中的<code>-</code>）。Leiningen项目的目录结构也是按照命名空间来的，这点和Java一致。</p>
<h3 id="入口文件：src-blog-server-clj"><a href="#入口文件：src-blog-server-clj" class="headerlink" title="入口文件：src/blog/server.clj"></a>入口文件：src/blog/server.clj</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> blog.server</div><div class="line">  (<span class="symbol">:require</span> [noir.server <span class="symbol">:as</span> server]))</div><div class="line"></div><div class="line">(<span class="name">server/load-views</span> <span class="string">"src/blog/views/"</span>)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> -main [&amp; m]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [mode (<span class="name"><span class="builtin-name">keyword</span></span> (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">first</span></span> m) <span class="symbol">:dev</span>))</div><div class="line">        port (<span class="name">Integer.</span> (<span class="name"><span class="builtin-name">get</span></span> (<span class="name">System/getenv</span>) <span class="string">"PORT"</span> <span class="string">"8080"</span>))]</div><div class="line">    (<span class="name">server/start</span> port &#123;<span class="symbol">:mode</span> mode</div><div class="line">                        <span class="symbol">:ns</span> 'blog&#125;)))</div></pre></td></tr></table></figure>
<p>ns宏用于定义当前的命名空间，:require表示导入其它命名空间，:as则是将为导入的命名空间设置别名。注意这些关键字及其用法都是在ns宏中定义的，这也是为什么说宏可以用来创造新的语法。</p>
<p>关于命名空间，你在执行<code>lein repl</code>的时候可能会注意到，当在blog项目下执行时，提示符是<code>blog.server=&gt;</code>，而在其他目录下执行时是<code>user=&gt;</code>，因为user是Clojure默认的命名空间，可以通过<code>(ns myspace)</code>来切换成<code>myspace=&gt;</code>。</p>
<p><code>server/load-views</code>表示调用<code>server</code>命名空间下的<code>load-views</code>函数，后面的<code>src/blog/views/</code>则是函数的参数。在大多数语言中，函数名称不能包含特殊字符，如<code>-</code>，但Clojure中的变量名、函数名、关键字等都可以包含诸如*、+、!、&gt;这样的特殊字符。其中一些字符是有特定含义的，如关键字必须以<code>:</code>开头，以<code>::</code>开头的则表示仅在当前命名空间中有效。这些约定需要注意。</p>
<p>defn宏用来定义一个函数，基本用法是<code>(defn 函数名 [参数列表] 语句1 语句2)</code>。如果参数数量不定，可以使用这样的语法<code>[arg1 arg2 &amp; args]</code>，这样当函数接收四个参数时，后两个参数会作为一个向量赋值给args变量。</p>
<p>关于let，它是继“宏”和“函数”之后出现的第三个术语，“特殊形式”(Special Form)。我们暂时不去了解它们之间的关系，先来看看let的作用。设想这样一个场景，我们在调用一个函数之前会准备一些参数传送给它，这些参数仅在函数内部可见，函数处理完后就会销毁。let则是将参数准备和函数调用这两步整合了起来。它的语法是<code>(let [变量1 表达式1 变量2 表达式2] 语句1 语句2)</code>，举例来说，尝试在REPL中执行以下命令，思考一下结果是如何得出的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user=&gt; (let [x 1 y (+ 2 3)] (+ x y))</div><div class="line">6</div><div class="line">user=&gt;</div></pre></td></tr></table></figure>
<p>入口文件中的表达式看起来有些复杂，但逐步拆解后就会明白：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">user=&gt; (def m []) ; 定义一个变量，它是一个空向量，正如不带参数调用-main函数时一样。Clojure中分号表示注释。</div><div class="line">user=&gt; (first m) ; 获取向量（序列）的第一个元素，这里为空。</div><div class="line">nil</div><div class="line">user=&gt; (or (first m) :dev) ; 从左往右执行参数，若结果不为空(nil)则停止执行，并返回该结果。</div><div class="line">:dev</div><div class="line">user=&gt; (keyword (or (first m) :dev)) ; 获取关键字。由于传入的参数可能是一个关键字、一个变量、或一个字符串，因此使用keyword函数返回一个关键字类型。</div><div class="line">:dev</div></pre></td></tr></table></figure>
<p>经过处理，mode变量包含了:dev这个关键字，且作用域仅在(let …)中有效。</p>
<p>再来看看port变量，这里涉及到了与Java类的交互：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">user=&gt; (System/getenv) ; 这里的System不是一个命名空间，而是Java的一个类。通过这种方式我们调用了System类的静态方法getenv，并返回了一个Map类实例。</div><div class="line">java.util.Collections$UnmodifiableMap</div><div class="line">user=&gt; (get (System/getenv) "PORT" "8080") ; 这里的get不是Map实例的get方法，而是Clojure中的一个函数，用于返回哈希表(map)中的值，不存在则返回一个默认值。</div><div class="line">"8080"</div><div class="line">user=&gt; (.get (System/getenv) "PORT") ; 这才是调用Map实例的get方法，注意点号和函数的参数。</div><div class="line">nil</div><div class="line">user=&gt; (Integer. (get (System/getenv) "PORT" "8080")) ; 又是一个和Java交互的语法：创建实例。它和以下语法等价：</div><div class="line">8080</div><div class="line">user=&gt; (new Integer (get (System/getenv) "PORT" "8080"))</div><div class="line">8080</div></pre></td></tr></table></figure>
<p>关于map再补充一点，它虽然是Clojure的一种数据类型，但底层其实是Map接口一个实现，因此以下语法是合法的。类似的情况在Clojure中还有很多。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user=&gt; (def m &#123;:a 1, :b 2&#125;) ; map的语法是&#123;键1 值1 键2 值2&#125;，为了加强可读性，这里使用了逗号分隔了两组键值，Clojure在编译时会将逗号转换成空格。</div><div class="line">user=&gt; (&lt; (get m :a) (.get m :b)) ; 1 &lt; 2</div><div class="line">true</div></pre></td></tr></table></figure>
<p>参数的赋值就结束了，后面的代码也很好理解：调用server命名空间下的start函数，参数是监听端口和一组由map表示的参数。这里blog之前的单引号需要注意，表示其后的代码不需要进行解析(evaluate)，在表示命空间名时都需要加上（ns宏除外），如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user=&gt; (require 'noir.server) ; 引入一个命名空间，使用noir.server/start调用方法。</div><div class="line">user=&gt; (alias 'server 'noir.server) ; 设置别名。</div><div class="line">user=&gt; (refer 'noir.server) ; 将该命名空间下的变量导入当当前命名空间中，即可以直接使用(start ...)调用。</div><div class="line">user=&gt; (use 'noir.server) ; 同时完成require和refer。</div></pre></td></tr></table></figure>
<p><strong>小贴士</strong></p>
<p>这一节中我们引入了不少Clojure的函数、宏、特殊形式，有时会需要查阅这些函数的用法。除了上网查找API文档，还可以在REPL中使用<code>doc</code>和<code>source</code>函数来返回某个函数或宏的文档和源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user=&gt; (doc first)</div><div class="line">-------------------------</div><div class="line">clojure.core/first</div><div class="line">([coll])</div><div class="line">  Returns the first item in the collection. Calls seq on its</div><div class="line">    argument. If coll is nil, returns nil.</div></pre></td></tr></table></figure>
<h3 id="基本页面：src-blog-views-welcome-clj"><a href="#基本页面：src-blog-views-welcome-clj" class="headerlink" title="基本页面：src/blog/views/welcome.clj"></a>基本页面：src/blog/views/welcome.clj</h3><p>入口文件中的<code>load-views</code>函数会将指定目录下的所有文件都包含进来，这些文件中定义的是URL路由以及页面内容，以welcome.clj为例：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> blog.views.welcome</div><div class="line">  (<span class="symbol">:require</span> [blog.views.common <span class="symbol">:as</span> common]</div><div class="line">            [noir.content.getting-started])</div><div class="line">  (<span class="symbol">:use</span> [noir.core <span class="symbol">:only</span> [defpage]]</div><div class="line">        [hiccup.core <span class="symbol">:only</span> [html]]))</div><div class="line"></div><div class="line">(<span class="name">defpage</span> <span class="string">"/welcome"</span> []</div><div class="line">         (<span class="name">common/layout</span></div><div class="line">           [<span class="symbol">:p</span> <span class="string">"Welcome to blog"</span>]))</div></pre></td></tr></table></figure>
<p>我们先跳过这些代码，来看看如何定义一个新的页面。将以下代码添加到welcome.clj尾部，然后执行<code>lein run</code>。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defpage</span> <span class="string">"/greeting"</span> []</div><div class="line">         (<span class="name">html</span></div><div class="line">           [<span class="symbol">:h1</span> <span class="string">"Hello, world!"</span>]))</div></pre></td></tr></table></figure>
<p>访问 <a href="http://127.0.0.1:8080/greeting" target="_blank" rel="external">http://127.0.0.1:8080/greeting</a> 就能看到一个新的页面了，页面源码是<code>&lt;h1&gt;Hello, world!&lt;/h1&gt;</code>。</p>
<p>defpage是Noir的一个宏，用来定义URL和它返回的页面内容。URL的定义有很多其他用法，如POST方式、截取参数等，我们稍后都会用到。页面内容方面，可以直接返回字符串，如<code>(defpage &quot;/greeting&quot; [] &quot;Hello, world!&quot;)</code>，也可以使用Hiccup构建HTML页面。<a href="https://github.com/weavejester/hiccup" target="_blank" rel="external">Hiccup</a>是Noir默认的模板引擎，简单来说就是用Clojure来写HTML。一个完整的页面示例如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> ...</div><div class="line">  (<span class="symbol">:use</span> ...</div><div class="line">        [hiccup.page-helpers <span class="symbol">:only</span> [html4]]))</div><div class="line">        </div><div class="line">(<span class="name">defpage</span> <span class="string">"/greeting"</span> []</div><div class="line">         (<span class="name">html4</span></div><div class="line">           [<span class="symbol">:head</span></div><div class="line">             [<span class="symbol">:title</span> <span class="string">"Greeting"</span>]]</div><div class="line">           [<span class="symbol">:body</span></div><div class="line">             [<span class="symbol">:h1</span> <span class="string">"Hello, world!"</span>]]))</div></pre></td></tr></table></figure>
<p>生成的HTML是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Greeting<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，html和html4都是Hiccup定义的宏。html仅将接收到的参数转换为HTML代码，html4则是会添加相应版本的<code>&lt;!DOCTYPE&gt;</code>和<code>&lt;html&gt;</code>标签。要使用这些宏需要引入相应的命名空间。:only则表示只引入命名空间中特定的宏。</p>
<p>关于命名空间中出现的<code>-</code>，Clojure在编译时会自动转换成<code>_</code>，从而确保程序在JVM中运行时不会出现问题。</p>
<h3 id="页面模板：src-blog-views-common-clj"><a href="#页面模板：src-blog-views-common-clj" class="headerlink" title="页面模板：src/blog/views/common.clj"></a>页面模板：src/blog/views/common.clj</h3><p>回到系统生成的welcome.clj文件，它并没有使用html或html4，而是调用了一个<code>common/layout</code>函数。那么让我们看看common.clj中这个函数的定义：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> blog.views.common</div><div class="line">  (<span class="symbol">:use</span> [noir.core <span class="symbol">:only</span> [defpartial]]</div><div class="line">        [hiccup.page-helpers <span class="symbol">:only</span> [include-css html5]]))</div><div class="line"></div><div class="line">(<span class="name">defpartial</span> layout [&amp; content]</div><div class="line">            (<span class="name">html5</span></div><div class="line">              [<span class="symbol">:head</span></div><div class="line">               [<span class="symbol">:title</span> <span class="string">"blog"</span>]</div><div class="line">               (<span class="name">include-css</span> <span class="string">"/css/reset.css"</span>)]</div><div class="line">              [<span class="symbol">:body</span></div><div class="line">               [<span class="symbol">:div#wrapper</span></div><div class="line">                content]]))</div></pre></td></tr></table></figure>
<p>defpartial是Noir的一个宏，用来定义一段可复用的HTML代码。当然我们也可以将其定义为一个函数（用<code>defn</code>替换掉<code>defpartial</code>），不会有什么区别。官方文档的解释是使用defpartial会比较容易辨认。</p>
<p><code>include-css</code>是一个函数，用来生成<code>&lt;link&gt;</code>标签。<code>[:div#wrapper ...]</code>会生成<code>&lt;div id=&quot;wrapper&quot;&gt;...&lt;/div&gt;</code>。更多Hiccup的语法可以到<a href="http://www.webnoir.org/tutorials/html" target="_blank" rel="external">这个页面</a>浏览一下。</p>
<h3 id="默认首页：noir-content-getting-started"><a href="#默认首页：noir-content-getting-started" class="headerlink" title="默认首页：noir.content.getting-started"></a>默认首页：noir.content.getting-started</h3><p>我们在代码中并没有看到<code>(defpage &quot;/&quot; [] ...)</code>这样的定义，那为什么网站根目录会出现一个默认页面呢？答案在<code>noir.content.getting-started</code>这个命名空间中，可以<a href="https://github.com/noir-clojure/noir/blob/master/src/noir/content/getting_started.clj" target="_blank" rel="external">点击这里</a>查看它的源码。要取消这个默认页面，可以在welcome.clj的:require中将其删除。</p>
<h3 id="静态资源：src-resources-public"><a href="#静态资源：src-resources-public" class="headerlink" title="静态资源：src/resources/public"></a>静态资源：src/resources/public</h3><p>Noir默认对src/resources/public目录下的文件做了路由，因此当有一个资源文件位于src/resources/public/css/reset.css时，可以通过<a href="http://127.0.0.1:8080/css/reset.css访问。" target="_blank" rel="external">http://127.0.0.1:8080/css/reset.css访问。</a></p>
<p>值得一提的是，Noir项目本身依赖于两个开源项目：<a href="https://github.com/ring-clojure/ring" target="_blank" rel="external">ring</a>和<a href="https://github.com/weavejester/compojure/tree/master/src" target="_blank" rel="external">compojure</a>，前者对HTTP请求进行了封装，提供了一套类似Python WSGI的API；后者则是专门提供URL路由功能的类库。如对静态资源的路由，实质上Noir是调用了compojure提供的resources函数，函数中又调用ring提供的GET、wrap-file-info等函数响应请求。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章讲述了Clojure环境的搭建，特别是项目管理工具<code>lein</code>的一般使用。通过对Noir项目骨架的分析，我们一窥Clojure的语法，接触了变量、直接量、函数、宏、命名空间的一些用法，并能结合Noir和Hiccup写出简单的页面来。下一章我们将讲解如何使用Noir编写表单页面进行交互，以及Clojure如何连接数据库，对博文进行增删改查等操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://shzhangji.com/blog/2012/11/25/cia-noir-1/" data-id="cirm6bhqv00067xvi05f6g560" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clojure/">clojure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/noir/">noir</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2012/12/08/cia-noir-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Clojure实战(2)：使用Noir框架开发博客(中)
        
      </div>
    </a>
  
  
    <a href="/blog/2012/11/18/aosa-python-packaging/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">开源软件架构 - 卷1：第14章 Python打包工具</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Big-Data/">Big Data</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/Big-Data/">Big Data</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Translation/">Translation</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Translation/Big-Data/">Big Data</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Translation/Tutorial/">Tutorial</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tutorial/">Tutorial</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tutorial/Big-Data/">Big Data</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aosa/">aosa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clojure/">clojure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fp/">fp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/noir/">noir</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ops/">ops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perl/">perl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/">programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storm/">storm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/aosa/" style="font-size: 13.33px;">aosa</a> <a href="/tags/clojure/" style="font-size: 20px;">clojure</a> <a href="/tags/fp/" style="font-size: 10px;">fp</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hadoop/" style="font-size: 13.33px;">hadoop</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/noir/" style="font-size: 16.67px;">noir</a> <a href="/tags/ops/" style="font-size: 10px;">ops</a> <a href="/tags/perl/" style="font-size: 13.33px;">perl</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/storm/" style="font-size: 10px;">storm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2015/09/12/model-dependency-injection-with-spring-aop/">使用Spring AOP向领域模型注入依赖</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/05/anemic-domain-model/">贫血领域模型</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/01/view-spark-source-in-eclipse/">View Spark Source in Eclipse</a>
          </li>
        
          <li>
            <a href="/blog/2015/06/25/compressed-oops-in-the-hotspot-jvm/">HotSpot JVM中的对象指针压缩</a>
          </li>
        
          <li>
            <a href="/blog/2015/05/31/spark-streaming-logging-configuration/">Spark Streaming Logging Configuration</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Ji ZHANG<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>