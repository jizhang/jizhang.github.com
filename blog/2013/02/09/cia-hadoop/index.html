<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Clojure实战(4)：编写Hadoop MapReduce脚本 | Ji ZHANG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hadoop简介众所周知，我们已经进入了大数据时代，每天都有PB级的数据需要处理、分析，从中提取出有用的信息。Hadoop就是这一时代背景下的产物。它是Apache基金会下的开源项目，受Google两篇论文的启发，采用分布式的文件系统HDFS，以及通用的MapReduce解决方案，能够在数千台物理节点上进行分布式并行计算。
对于Hadoop的介绍这里不再赘述，读者可以访问其官网，或阅读Hadoop">
<meta property="og:type" content="article">
<meta property="og:title" content="Clojure实战(4)：编写Hadoop MapReduce脚本">
<meta property="og:url" content="http://shzhangji.com/blog/2013/02/09/cia-hadoop/index.html">
<meta property="og:site_name" content="Ji ZHANG's Blog">
<meta property="og:description" content="Hadoop简介众所周知，我们已经进入了大数据时代，每天都有PB级的数据需要处理、分析，从中提取出有用的信息。Hadoop就是这一时代背景下的产物。它是Apache基金会下的开源项目，受Google两篇论文的启发，采用分布式的文件系统HDFS，以及通用的MapReduce解决方案，能够在数千台物理节点上进行分布式并行计算。
对于Hadoop的介绍这里不再赘述，读者可以访问其官网，或阅读Hadoop">
<meta property="og:image" content="http://shzhangji.com/images/cia-hadoop/wordcount.png">
<meta property="og:updated_time" content="2016-09-05T13:25:19.360Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clojure实战(4)：编写Hadoop MapReduce脚本">
<meta name="twitter:description" content="Hadoop简介众所周知，我们已经进入了大数据时代，每天都有PB级的数据需要处理、分析，从中提取出有用的信息。Hadoop就是这一时代背景下的产物。它是Apache基金会下的开源项目，受Google两篇论文的启发，采用分布式的文件系统HDFS，以及通用的MapReduce解决方案，能够在数千台物理节点上进行分布式并行计算。
对于Hadoop的介绍这里不再赘述，读者可以访问其官网，或阅读Hadoop">
<meta name="twitter:image" content="http://shzhangji.com/images/cia-hadoop/wordcount.png">
<meta name="twitter:creator" content="@zjerryj">
<link rel="publisher" href="zhangji87@gmail.com">
  
    <link rel="alternate" href="/atom.xml" title="Ji ZHANG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-37223379-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ji ZHANG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">If I rest, I rust.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/categories/Big-Data">Big Data</a>
        
          <a class="main-nav-link" href="/categories/Programming">Programming</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shzhangji.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cia-hadoop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2013/02/09/cia-hadoop/" class="article-date">
  <time datetime="2013-02-09T16:43:00.000Z" itemprop="datePublished">2013-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tutorial/">Tutorial</a>►<a class="article-category-link" href="/categories/Tutorial/Big-Data/">Big Data</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Clojure实战(4)：编写Hadoop MapReduce脚本
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h2><p>众所周知，我们已经进入了大数据时代，每天都有PB级的数据需要处理、分析，从中提取出有用的信息。Hadoop就是这一时代背景下的产物。它是Apache基金会下的开源项目，受<a href="http://en.wikipedia.org/wiki/Apache_Hadoop#Papers" target="_blank" rel="external">Google两篇论文</a>的启发，采用分布式的文件系统HDFS，以及通用的MapReduce解决方案，能够在数千台物理节点上进行分布式并行计算。</p>
<p>对于Hadoop的介绍这里不再赘述，读者可以<a href="http://hadoop.apache.org/" target="_blank" rel="external">访问其官网</a>，或阅读<a href="http://product.dangdang.com/main/product.aspx?product_id=21127813" target="_blank" rel="external">Hadoop权威指南</a>。</p>
<p>Hadoop项目是由Java语言编写的，运行在JVM之上，因此我们可以直接使用Clojure来编写MapReduce脚本，这也是本文的主题。Hadoop集群的搭建不在本文讨论范围内，而且运行MapReduce脚本也无需搭建测试环境。</p>
<a id="more"></a>
<h2 id="clojure-hadoop类库"><a href="#clojure-hadoop类库" class="headerlink" title="clojure-hadoop类库"></a>clojure-hadoop类库</h2><p>Hadoop提供的API是面向Java语言的，如果不想在Clojure中过多地操作Java对象，那就需要对API进行包装（wrapper），好在已经有人为我们写好了，它就是<a href="https://github.com/alexott/clojure-hadoop" target="_blank" rel="external">clojure-hadoop</a>。</p>
<p>从clojure-hadoop的项目介绍中可以看到，它提供了不同级别的包装，你可以选择完全规避对Hadoop类型和对象的操作，使用纯Clojure语言来编写脚本；也可以部分使用Hadoop对象，以提升性能（因为省去了类型转换过程）。这里我们选择前一种，即完全使用Clojure语言。</p>
<h2 id="示例1：Wordcount"><a href="#示例1：Wordcount" class="headerlink" title="示例1：Wordcount"></a>示例1：Wordcount</h2><p>Wordcount，统计文本文件中每个单词出现的数量，可以说是数据处理领域的“Hello, world!”。这一节我们就通过它来学习如何编写MapReduce脚本。</p>
<h3 id="Leiningen-2"><a href="#Leiningen-2" class="headerlink" title="Leiningen 2"></a>Leiningen 2</h3><p>前几章我们使用的项目管理工具<code>lein</code>是1.7版的，而前不久Leiningen 2已经正式发布了，因此从本章开始我们的示例都会基于新版本。新版<code>lein</code>的安装过程也很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/bin</div><div class="line">$ wget https://raw.github.com/technomancy/leiningen/stable/bin/lein</div><div class="line">$ chmod 755 lein</div><div class="line">$ lein repl</div><div class="line">user=&gt;</div></pre></td></tr></table></figure>
<p>其中，<code>lein repl</code>这一步会下载<code>lein</code>运行时需要的文件，包括Clojure 1.4。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lein new cia-hadoop</div></pre></td></tr></table></figure>
<p>编辑<code>project.clj</code>文件，添加依赖项<code>clojure-hadoop &quot;1.4.1&quot;</code>，尔后执行<code>lein deps</code>。</p>
<h3 id="Map和Reduce"><a href="#Map和Reduce" class="headerlink" title="Map和Reduce"></a>Map和Reduce</h3><p>MapReduce，简称mapred，是Hadoop的核心概念之一。可以将其理解为处理问题的一种方式，即将大问题拆分成多个小问题来分析和解决，最终合并成一个结果。其中拆分的过程就是Map，合并的过程就是Reduce。</p>
<p>以Wordcount为例，将一段文字划分成一个个单词的过程就是Map。这个过程是可以并行执行的，即将文章拆分成多个段落，每个段落分别在不同的节点上执行划分单词的操作。这个过程结束后，我们便可以统计各个单词出现的次数，这也就是Reduce的过程。同样，Reduce也是可以并发执行的。整个过程如下图所示：</p>
<p><img src="/images/cia-hadoop/wordcount.png" alt="Wordcount"></p>
<p>中间Shuffle部分的功能是将Map输出的数据按键排序，交由Reduce处理。整个过程全部由Hadoop把控，开发者只需编写<code>Map</code>和<code>Reduce</code>函数，这也是Hadoop强大之处。</p>
<h4 id="编写Map函数"><a href="#编写Map函数" class="headerlink" title="编写Map函数"></a>编写Map函数</h4><p>在本示例中，我们处理的原始数据是文本文件，Hadoop会逐行读取并调用Map函数。Map函数会接收到两个参数：<code>key</code>是一个长整型，表示该行在整个文件中的偏移量，很少使用；<code>value</code>则是该行的内容。以下是将一行文字拆分成单词的Map函数：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; src/cia_hadoop/wordcount.clj</span></div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> cia-hadoop.wordcount</div><div class="line">  (<span class="symbol">:require</span> [clojure-hadoop.wrap <span class="symbol">:as</span> wrap]</div><div class="line">            [clojure-hadoop.defjob <span class="symbol">:as</span> defjob])</div><div class="line">  (<span class="symbol">:import</span> [java.util StringTokenizer])</div><div class="line">  (<span class="symbol">:use</span> clojure-hadoop.job))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-map [key value]</div><div class="line">  (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [token] [token <span class="number">1</span>])</div><div class="line">       (<span class="name">enumeration-seq</span> (<span class="name">StringTokenizer.</span> value))))</div></pre></td></tr></table></figure>
<p>可以看到，这是一个纯粹的Clojure函数，并没有调用Hadoop的API。函数体虽然只有两行，但还是包含了很多知识点的：</p>
<p><code>(map f coll)</code>函数的作用是将函数<code>f</code>应用到序列<code>coll</code>的每个元素上，并返回一个新的序列。如<code>(map inc [1 2 3])</code>会对每个元素做加1操作（参考<code>(doc inc)</code>），返回<code>[2 3 4]</code>。值得一提的是，<code>map</code>函数返回的是一个惰性序列（lazy sequence），即序列元素不会一次性完全生成，而是在遍历过程中逐个生成，这在处理元素较多的序列时很有优势。</p>
<p><code>map</code>函数接收的参数自然不会只限于Clojure内部函数，我们可以将自己定义的函数传递给它：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-inc [x]</div><div class="line">  (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">map</span></span> my-inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]) <span class="comment">; -&gt; [2 3 4]</span></div></pre></td></tr></table></figure>
<p>我们更可以传递一个匿名函数给<code>map</code>。上一章提过，定义匿名函数的方式是使用<code>fn</code>，另外还可使用<code>#(...)</code>简写：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x] (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)) [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])</div><div class="line">(<span class="name"><span class="builtin-name">map</span></span> #(<span class="name"><span class="builtin-name">+</span></span> % <span class="number">1</span>) [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>对于含有多个参数的情况：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">((<span class="name"><span class="builtin-name">fn</span></span> [x y] (<span class="name"><span class="builtin-name">+</span></span> x y)) <span class="number">1</span> <span class="number">2</span>) <span class="comment">; -&gt; 3</span></div><div class="line">(<span class="name">#</span>(<span class="name"><span class="builtin-name">+</span></span> %<span class="number">1</span> %<span class="number">2</span>) <span class="number">1</span> <span class="number">2</span>) <span class="comment">; -&gt; 3</span></div></pre></td></tr></table></figure>
<p><code>my-map</code>中的<code>(fn [token] [token 1])</code>即表示接收参数<code>token</code>，返回一个向量<code>[token 1]</code>，其作用等价于<code>#(vector % 1)</code>。为何是<code>[token 1]</code>，是因为Hadoop的数据传输都是以键值对的形式进行的，如<code>[&quot;apple&quot; 1]</code>即表示“apple”这个单词出现一次。</p>
<p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html" target="_blank" rel="external">StringTokenizer</a>则是用来将一行文字按空格拆分成单词的。他的返回值是<code>Enumeration</code>类型，Clojure提供了<code>enumeration-seq</code>函数，可以将其转换成序列进行操作。</p>
<p>所以最终<code>my-map</code>函数的作用就是：将一行文字按空格拆分成单词，返回一个形如<code>[[&quot;apple&quot; 1] [&quot;orange&quot; 1] ...]</code>的序列。</p>
<h4 id="编写Reduce函数"><a href="#编写Reduce函数" class="headerlink" title="编写Reduce函数"></a>编写Reduce函数</h4><p>从上文的图表中可以看到，Map函数处理完成后，Hadoop会对结果按照键进行排序，并使用<code>key, [value1 value2 ...]</code>的形式调用Reduce函数。在clojure-hadoop中，Reduce函数的第二个参数是一个函数，其返回结果才是值的序列：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-reduce [key values-fn]</div><div class="line">  [[key (<span class="name"><span class="builtin-name">reduce</span></span> + (<span class="name">values-fn</span>))]])</div></pre></td></tr></table></figure>
<p>和Map函数相同，Reduce函数的返回值也是一个序列，其元素是一个个<code>[key value]</code>。注意，函数体中的<code>(reduce f coll)</code>是Clojure的内置函数，其作用是：取<code>coll</code>序列的第1、2个元素作为参数执行函数<code>f</code>，将结果和<code>coll</code>序列的第3个元素作为参数执行函数<code>f</code>，依次类推。因此<code>(reduce + [1 2 3])</code>等价于<code>(+ (+ 1 2) 3)</code>。</p>
<h4 id="定义脚本"><a href="#定义脚本" class="headerlink" title="定义脚本"></a>定义脚本</h4><p>有了Map和Reduce函数，我们就可以定义一个完整的脚本了：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defjob/defjob</span> job</div><div class="line">  <span class="symbol">:map</span> my-map</div><div class="line">  <span class="symbol">:map-reader</span> wrap/int-string-map-reader</div><div class="line">  <span class="symbol">:reduce</span> my-reduce</div><div class="line">  <span class="symbol">:input-format</span> <span class="symbol">:text</span></div><div class="line">  <span class="symbol">:output-format</span> <span class="symbol">:text</span></div><div class="line">  <span class="symbol">:compress-output</span> <span class="literal">false</span></div><div class="line">  <span class="symbol">:replace</span> <span class="literal">true</span></div><div class="line">  <span class="symbol">:input</span> <span class="string">"README.md"</span></div><div class="line">  <span class="symbol">:output</span> <span class="string">"out-wordcount"</span>)</div></pre></td></tr></table></figure>
<p>简单说明一下这些配置参数：<code>:map</code>和<code>:reduce</code>分别指定Map和Reduce函数；<code>map-reader</code>表示读取数据文件时采用键为<code>int</code>、值为<code>string</code>的形式；<code>:input-format</code>至<code>compress-output</code>指定了输入输出的文件格式，这里采用非压缩的文本形式，方便阅览；<code>:replace</code>表示每次执行时覆盖上一次的结果；<code>:input</code>和<code>:output</code>则是输入的文件和输出的目录。</p>
<h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><p>我们可以采用Clojure的测试功能来执行脚本：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; test/cia_hadoop/wordcount_test.clj</span></div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> cia-hadoop.wordcount-test</div><div class="line">  (<span class="symbol">:use</span> clojure.test</div><div class="line">        clojure-hadoop.job</div><div class="line">        cia-hadoop.wordcount))</div><div class="line"></div><div class="line">(<span class="name">deftest</span> test-wordcount</div><div class="line">  (<span class="name">is</span> (<span class="name">run</span> job)))</div></pre></td></tr></table></figure>
<p>尔后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ lein <span class="built_in">test</span> cia-hadoop.wordcount-test</div><div class="line">...</div><div class="line">13/02/14 00:25:52 INFO mapred.JobClient:  map 0% reduce 0%</div><div class="line">..</div><div class="line">13/02/14 00:25:58 INFO mapred.JobClient:  map 100% reduce 100%</div><div class="line">...</div><div class="line">$ cat out-wordcount/part-r-00000</div><div class="line">...</div><div class="line"><span class="string">"java"</span>  1</div><div class="line"><span class="string">"lein"</span>	3</div><div class="line"><span class="string">"locally"</span>	2</div><div class="line"><span class="string">"on"</span>	1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如果想要将MapReduce脚本放到Hadoop集群中执行，可以采用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ lein uberjar</div><div class="line">$ hadoop jar target/cia-hadoop-0.1.0-SNAPSHOT-standalone.jar clojure_hadoop.job -job cia-hadoop.wordcount/job</div></pre></td></tr></table></figure>
<h2 id="示例2：统计浏览器类型"><a href="#示例2：统计浏览器类型" class="headerlink" title="示例2：统计浏览器类型"></a>示例2：统计浏览器类型</h2><p>下面我们再来看一个更为实际的示例：从用户的访问日志中统计浏览器类型。</p>
<h3 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h3><p>用户访问网站时，页面中会有段JS请求，将用户的IP、User-Agent等信息发送回服务器，并记录成文本文件的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;stamp&quot;: &quot;1346376858286&quot;, &quot;ip&quot;: &quot;58.22.113.189&quot;, &quot;agent&quot;: &quot;Mozilla/5.0 (iPad; CPU OS 5_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A405 Safari/7534.48.3&quot;&#125;</div><div class="line">&#123;&quot;stamp&quot;: &quot;1346376858354&quot;, &quot;ip&quot;: &quot;116.233.51.2&quot;, &quot;agent&quot;: &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot;&#125;</div><div class="line">&#123;&quot;stamp&quot;: &quot;1346376858365&quot;, &quot;ip&quot;: &quot;222.143.28.2&quot;, &quot;agent&quot;: &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)&quot;&#125;</div><div class="line">&#123;&quot;stamp&quot;: &quot;1346376858423&quot;, &quot;ip&quot;: &quot;123.151.144.40&quot;, &quot;agent&quot;: &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;&#125;</div></pre></td></tr></table></figure>
<p>我们要做的是从User-Agent中统计用户使用的浏览器类型所占比例，包括IE、Firefox、Chrome、Opera、Safari、以及其它。</p>
<h3 id="User-Agent中的浏览器类型"><a href="#User-Agent中的浏览器类型" class="headerlink" title="User-Agent中的浏览器类型"></a>User-Agent中的浏览器类型</h3><p>由于一些<a href="http://webaim.org/blog/user-agent-string-history/" target="_blank" rel="external">历史原因</a>，User-Agent中的信息是比较凌乱的，浏览器厂商会随意添加信息，甚至仿造其它浏览器的内容。因此在过滤时，我们需要做些额外的处理。Mozilla的<a href="https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent" target="_blank" rel="external">这篇文章</a>很好地概括了如何从User-Agent中获取浏览器类型，大致如下：</p>
<ul>
<li>IE: MSIE xyz</li>
<li>Firefox: Firefox/xyz</li>
<li>Chrome: Chrome/xyz</li>
<li>Opera: Opera/xyz</li>
<li>Safari: Safari/xyz, 且不包含 Chrome/xyz 和 Chromium/xyz</li>
</ul>
<h3 id="解析JSON字符串"><a href="#解析JSON字符串" class="headerlink" title="解析JSON字符串"></a>解析JSON字符串</h3><p>Clojure除了内置函数之外，周边还有一个名为<code>clojure.contrib</code>的类库，其中囊括了各类常用功能，包括JSON处理。目前<code>clojure.contrib</code>中的各个组件已经分开发行，读者可以到 <a href="https://github.com/clojure" target="_blank" rel="external">https://github.com/clojure</a> 中浏览。</p>
<p>处理JSON字符串时，首先在项目声明文件中添加依赖项<code>[org.clojure/data.json &quot;0.2.1&quot;]</code>，然后就能使用了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">user=&gt; (require '[clojure.data.json :as json])</div><div class="line">user=&gt; (json/read-str "&#123;\"a\":1,\"b\":2&#125;")</div><div class="line">&#123;"a" 1, "b" 2&#125;</div><div class="line">user=&gt; (json/write-str [1 2 3])</div><div class="line">"[1,2,3]"</div></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Clojure提供了一系列的内置函数来使用正则表达式，其实质上是对<code>java.util.regex</code>命名空间的包装。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">user=&gt; (def ptrn #"[0-9]+") ; #"..."是定义正则表达式对象的简写形式</div><div class="line">user=&gt; (def ptrn (re-pattern "[0-9]+")) ; 和上式等价</div><div class="line">user=&gt; (re-matches ptrn "123") ; 完全匹配</div><div class="line">"123"</div><div class="line">user=&gt; (re-find ptrn "a123") ; 返回第一个匹配项</div><div class="line">"123"</div><div class="line">user=&gt; (re-seq ptrn "a123b456") ; 返回匹配项序列（惰性序列）</div><div class="line">("123" "456")</div><div class="line">user=&gt; (re-find #"([a-z]+)/([0-9]+)" "a/1") ; 子模式</div><div class="line">["a/1" "a" "1"]</div><div class="line">user=&gt; (def m (re-matcher #"([a-z]+)/([0-9]+)" "a/1 b/2")) ; 返回一个Matcher对象</div><div class="line">user=&gt; (re-find m) ; 返回第一个匹配</div><div class="line">["a/1" "a" "1"]</div><div class="line">user=&gt; (re-groups m) ; 获取当前匹配</div><div class="line">["a/1" "a" "1"]</div><div class="line">user=&gt; (re-find m) ; 返回下一个匹配，或nil</div><div class="line">["b/2" "b" "2"]</div></pre></td></tr></table></figure>
<h3 id="Map函数"><a href="#Map函数" class="headerlink" title="Map函数"></a>Map函数</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> json-decode [s]</div><div class="line">  (<span class="name"><span class="builtin-name">try</span></span></div><div class="line">    (<span class="name">json/read-str</span> s)</div><div class="line">    (<span class="name">catch</span> Exception e)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">def</span></span> rule-set &#123;<span class="string">"ie"</span> (<span class="name"><span class="builtin-name">partial</span></span> re-find #<span class="string">"(?i)MSIE [0-9]+"</span>)</div><div class="line">               <span class="string">"chrome"</span> (<span class="name"><span class="builtin-name">partial</span></span> re-find #<span class="string">"(?i)Chrome/[0-9]+"</span>)</div><div class="line">               <span class="string">"firefox"</span> (<span class="name"><span class="builtin-name">partial</span></span> re-find #<span class="string">"(?i)Firefox/[0-9]+"</span>)</div><div class="line">               <span class="string">"opera"</span> (<span class="name"><span class="builtin-name">partial</span></span> re-find #<span class="string">"(?i)Opera/[0-9]+"</span>)</div><div class="line">               <span class="string">"safari"</span> #(<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">re-find</span></span> #<span class="string">"(?i)Safari/[0-9]+"</span> %)</div><div class="line">                              (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">re-find</span></span> #<span class="string">"(?i)Chrom(e|ium)/[0-9]+"</span> %)))</div><div class="line">               &#125;)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> get-type [ua]</div><div class="line">  (<span class="name"><span class="builtin-name">if-let</span></span> [rule (<span class="name"><span class="builtin-name">first</span></span> (<span class="name"><span class="builtin-name">filter</span></span> #((<span class="name"><span class="builtin-name">second</span></span> %) ua) rule-set))]</div><div class="line">    (<span class="name"><span class="builtin-name">first</span></span> rule)</div><div class="line">    <span class="string">"other"</span>))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-map [key value]</div><div class="line">  (<span class="name"><span class="builtin-name">when-let</span></span> [ua (<span class="name"><span class="builtin-name">get</span></span> (<span class="name">json-decode</span> value) <span class="string">"agent"</span>)]</div><div class="line">    [[(<span class="name">get-type</span> ua) <span class="number">1</span>]]))</div></pre></td></tr></table></figure>
<p><code>json-decode</code>函数是对<code>json/read-str</code>的包装，当JSON字符串无法正确解析时返回<code>nil</code>，而非异常终止。</p>
<p><code>rule-set</code>是一个<code>map</code>类型，键是浏览器名称，值是一个函数，这里都是匿名函数。<code>partial</code>用于构造新的函数，<code>(partial + 1)</code>和<code>#(+ 1 %)</code>、<code>(fn [x] (+ 1 x))</code>是等价的，可以将其看做是为函数<code>+</code>的第一个参数定义了默认值。正则表达式中的<code>(?i)</code>表示匹配时不区分大小写。</p>
<p><code>get-type</code>函数中，<code>(filter #((second %) ua) rule-set)</code>会用<code>rule-set</code>中的正则表达式逐一去和User-Agent字符串进行匹配，并返回第一个匹配项，也就是浏览器类型；没有匹配到的则返回<code>other</code>。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>我们可以编写一组单元测试来检验上述<code>my-map</code>函数是否正确：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; test/cia_hadoop/browser_test.clj</span></div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> cia-hadoop.browser-test</div><div class="line">  (<span class="symbol">:use</span> clojure.test</div><div class="line">        clojure-hadoop.job</div><div class="line">        cia-hadoop.browser))</div><div class="line"></div><div class="line">(<span class="name">deftest</span> test-my-map</div><div class="line">  (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> [[<span class="string">"ie"</span> <span class="number">1</span>]] (<span class="name">my-map</span> <span class="number">0</span> <span class="string">"&#123;\"agent\":\"MSIE 6.0\"&#125;"</span>)))</div><div class="line">  (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> [[<span class="string">"chrome"</span> <span class="number">1</span>]] (<span class="name">my-map</span> <span class="number">0</span> <span class="string">"&#123;\"agent\":\"Chrome/20.0 Safari/6533.2\"&#125;"</span>)))</div><div class="line">  (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> [[<span class="string">"other"</span> <span class="number">1</span>]] (<span class="name">my-map</span> <span class="number">0</span> <span class="string">"&#123;\"agent\":\"abc\"&#125;"</span>)))</div><div class="line">  (<span class="name">is</span> (<span class="name"><span class="builtin-name">nil?</span></span> (<span class="name">my-map</span> <span class="number">0</span> <span class="string">"&#123;"</span>))))</div><div class="line"></div><div class="line">(<span class="name">deftest</span> test-browser</div><div class="line">  (<span class="name">is</span> (<span class="name">run</span> job)))</div></pre></td></tr></table></figure>
<p>其中<code>deftest</code>和<code>is</code>都是<code>clojure.test</code>命名空间下定义的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lein <span class="built_in">test</span> cia-hadoop.browser-test</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章我们简单介绍了Hadoop这一用于大数据处理的开源项目，以及如何借助clojure-hadoop类库编写MapReduce脚本，并在本地和集群上运行。Hadoop已经将大数据处理背后的种种细节都包装了起来，用户只需编写Map和Reduce函数，而借助Clojure语言，这一步也变的更为轻松和高效。Apache Hadoop是一个生态圈，其周边有很多开源项目，像Hive、HBase等，这里再推荐一个使用Clojure语言在Hadoop上执行查询的工具：<a href="https://github.com/nathanmarz/cascalog" target="_blank" rel="external">cascalog</a>。它的作者是<a href="http://nathanmarz.com/" target="_blank" rel="external">Nathan Marz</a>，也是我们下一章的主题——Storm实时计算框架——的作者。</p>
<p>本文涉及到的源码可以到 <a href="https://github.com/jizhang/cia-hadoop" target="_blank" rel="external">https://github.com/jizhang/cia-hadoop</a> 中查看。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://shzhangji.com/blog/2013/02/09/cia-hadoop/" data-id="ciwah8dbx000i5zm6qisk1glr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clojure/">clojure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hadoop/">hadoop</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2013/03/07/currying-and-partial-application/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          柯里化与偏应用（JavaScript描述）
        
      </div>
    </a>
  
  
    <a href="/blog/2013/01/04/clojure-style-guide/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Clojure 代码规范</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/aosa/" style="font-size: 12.5px;">aosa</a> <a href="/tags/clojure/" style="font-size: 20px;">clojure</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/english/" style="font-size: 17.5px;">english</a> <a href="/tags/fp/" style="font-size: 10px;">fp</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hadoop/" style="font-size: 12.5px;">hadoop</a> <a href="/tags/hive/" style="font-size: 10px;">hive</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/noir/" style="font-size: 15px;">noir</a> <a href="/tags/ops/" style="font-size: 10px;">ops</a> <a href="/tags/perl/" style="font-size: 12.5px;">perl</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/scala/" style="font-size: 10px;">scala</a> <a href="/tags/scalatra/" style="font-size: 10px;">scalatra</a> <a href="/tags/spark/" style="font-size: 12.5px;">spark</a> <a href="/tags/storm/" style="font-size: 10px;">storm</a> <a href="/tags/translation/" style="font-size: 10px;">translation</a> <a href="/tags/webjars/" style="font-size: 10px;">webjars</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/03/13/top-5-frameworks/">开发人员必知的5种开源框架</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/12/model-dependency-injection-with-spring-aop/">使用Spring AOP向领域模型注入依赖</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/05/anemic-domain-model/">贫血领域模型</a>
          </li>
        
          <li>
            <a href="/blog/2015/09/01/view-spark-source-in-eclipse/">View Spark Source in Eclipse</a>
          </li>
        
          <li>
            <a href="/blog/2015/06/25/compressed-oops-in-the-hotspot-jvm/">HotSpot JVM中的对象指针压缩</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Ji ZHANG<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories/Big-Data" class="mobile-nav-link">Big Data</a>
  
    <a href="/categories/Programming" class="mobile-nav-link">Programming</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>